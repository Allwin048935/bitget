import ccxt.async_support as ccxt
import pandas as pd
import requests
import time
import hmac
import hashlib
import json
import asyncio
import ta
import base64
from config import BITGET_API_KEY, BITGET_API_SECRET, BITGET_PASSPHRASE, time_interval

# Trading parameters for all symbols
trading_params = {
    "market_type": "swap",
    "margin_mode": "isolated",
    "leverage": 3,
    "product_type": "USDT-FUTURES",
    "tp_trigger_type": "mark_price",
    "sl_trigger_type": "mark_price",
    "tp_percentage": 5,
    "sl_percentage": 2
}

# API endpoints for Bitget
BASE_URL = "https://api.bitget.com"
PLACE_ORDER_URL = f"{BASE_URL}/api/v2/mix/order/place-order"
PLACE_TPSL_URL = f"{BASE_URL}/api/v2/mix/order/place-tpsl-order"
CONTRACTS_URL = f"{BASE_URL}/api/mix/v1/market/contracts"

# Function to fetch USDT trading pairs with minTradeNum dynamically
def get_usdt_pairs():
    url = f"{CONTRACTS_URL}?productType=umcbl"
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        if 'data' in data and isinstance(data['data'], list):
            usdt_pairs = {}
            for item in data['data']:
                if 'USDT' in item['symbol']:
                    try:
                        min_trade_num = float(item['minTradeNum'])
                        full_symbol = item['symbol']  # e.g., BTCUSDT_UMCBL
                        base_symbol = item['symbol'].split('_')[0]  # e.g., BTCUSDT
                        usdt_pairs[base_symbol] = {'full_symbol': full_symbol, 'min_amount': min_trade_num}
                    except (KeyError, ValueError) as e:
                        print(f"Error parsing minTradeNum for {item['symbol']}: {e}")
                        usdt_pairs[item['symbol'].split('_')[0]] = {'full_symbol': item['symbol'], 'min_amount': 0.0001}
            return usdt_pairs
        else:
            print("Unexpected data format.")
            return {}
    except requests.exceptions.RequestException as e:
        print(f"Error fetching USDT pairs from Bitget: {e}")
        return {}

# Create a Bitget client
exchange = ccxt.bitget({
    'apiKey': BITGET_API_KEY,
    'secret': BITGET_API_SECRET,
    'password': BITGET_PASSPHRASE,
    'options': {'defaultType': 'swap'},
    'enableRateLimit': True
})

# Define EMA period for MACD calculation
macd_ema_period = 3

# Get initial symbols and their min_amounts
symbols_info = get_usdt_pairs()
symbols = list(symbols_info.keys())

# Track last order types, open orders, and last signals
last_order_types = {symbol: None for symbol in symbols}
open_orders = {symbol: None for symbol in symbols}
last_signals = {symbol: None for symbol in symbols}

# Function to generate signature for Bitget API
def generate_signature(timestamp, method, path, query_string="", body="", secret=BITGET_API_SECRET):
    message = f"{timestamp}{method.upper()}{path}{body}" if not query_string else f"{timestamp}{method.upper()}{path}?{query_string}{body}"
    print(f"Signature message: {message}")  # Clean debug output
    hmac_obj = hmac.new(secret.encode('utf-8'), message.encode('utf-8'), hashlib.sha256)
    signature = base64.b64encode(hmac_obj.digest()).decode('utf-8')
    print(f"Generated signature: {signature}")
    return signature

# Function to place market order
def place_order(base_symbol, side, trade_side, quantity):
    timestamp = str(int(time.time() * 1000))
    path = "/api/v2/mix/order/place-order"
    full_symbol = symbols_info[base_symbol]['full_symbol']
    
    params = {
        "symbol": full_symbol,
        "productType": trading_params["product_type"],
        "marginMode": trading_params["margin_mode"],
        "marginCoin": "USDT",
        "size": str(quantity),
        "side": side,
        "tradeSide": trade_side,
        "orderType": "market",
        "force": "ioc",
        "clientOid": f"{base_symbol}_{timestamp}"
    }

    body = json.dumps(params, separators=(',', ':'))
    headers = {
        "ACCESS-KEY": BITGET_API_KEY,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": BITGET_PASSPHRASE,
        "Content-Type": "application/json",
        "ACCESS-SIGN": generate_signature(timestamp, "POST", path, "", body)
    }

    print(f"Request body: {body}")  # Debug: Log exact body being sent
    print(f"Headers: {headers}")    # Debug: Log headers

    try:
        response = requests.post(PLACE_ORDER_URL, headers=headers, data=body)
        response.raise_for_status()
        data = response.json()
        if data.get('code') == "00000" and data.get('data'):
            order_id = data['data'].get('orderId') or data['data'][0].get('orderId')
            print(f"Order placed for {base_symbol}: {side}/{trade_side} - OrderId: {order_id}")
            return order_id
        else:
            print(f"Failed to place order for {base_symbol}: {data}")
            return None
    except requests.exceptions.RequestException as e:
        response_text = e.response.text if e.response else "No response body"
        print(f"Error placing order for {base_symbol}: {e} - Response: {response_text}")
        return None

# Function to place TP/SL order
def place_tpsl_order(base_symbol, hold_side, quantity, entry_price, plan_type, trigger_price):
    timestamp = str(int(time.time() * 1000))
    path = "/api/v2/mix/order/place-tpsl-order"
    full_symbol = symbols_info[base_symbol]['full_symbol']
    
    params = {
        "marginCoin": "USDT",
        "productType": trading_params["product_type"],
        "symbol": full_symbol,
        "planType": plan_type,
        "triggerPrice": str(trigger_price),
        "triggerType": trading_params["tp_trigger_type"] if plan_type == "profit_plan" else trading_params["sl_trigger_type"],
        "holdSide": hold_side,
        "size": str(quantity),
        "clientOid": f"{base_symbol}_{plan_type}_{timestamp}"
    }

    body = json.dumps(params, separators=(',', ':'))
    headers = {
        "ACCESS-KEY": BITGET_API_KEY,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": BITGET_PASSPHRASE,
        "Content-Type": "application/json",
        "ACCESS-SIGN": generate_signature(timestamp, "POST", path, "", body)
    }

    try:
        response = requests.post(PLACE_TPSL_URL, headers=headers, data=body)
        response.raise_for_status()
        data = response.json()
        if data.get('code') == "00000" and data.get('data'):
            order_id = data['data'].get('orderId')
            print(f"{plan_type.capitalize()} order placed for {base_symbol}: Trigger {trigger_price} - OrderId: {order_id}")
            return order_id
        else:
            print(f"Failed to place {plan_type} for {base_symbol}: {data}")
            return None
    except requests.exceptions.RequestException as e:
        response_text = e.response.text if e.response else "No response body"
        print(f"Error placing {plan_type} for {base_symbol}: {e} - Response: {response_text}")
        return None

# Async function to set trading parameters
async def set_trading_parameters(base_symbol, trade_side, side):
    try:
        if trade_side == 'open':
            hold_side = 'long' if side == 'buy' else 'short'
        else:
            last_order = last_order_types.get(base_symbol)
            hold_side = 'short' if last_order == 'BUY' else 'long'
        
        await exchange.set_leverage(
            trading_params['leverage'], 
            base_symbol,
            params={
                'marginMode': trading_params['margin_mode'],
                'holdSide': hold_side
            }
        )
        print(f"Set parameters for {base_symbol}: Leverage {trading_params['leverage']}x, {trading_params['margin_mode']} mode, HoldSide: {hold_side}")
        return True
    except Exception as e:
        print(f"Error setting trading parameters for {base_symbol}: {e}")
        return False

# Function to calculate EMA
def calculate_ema(df, period, column='close'):
    return df[column].ewm(span=period, adjust=False).mean()

# Async function to fetch historical data and calculate MACD
async def fetch_ohlcv(base_symbol, timeframe, limit):
    try:
        ohlcv = await exchange.fetch_ohlcv(base_symbol, timeframe, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['ema_9'] = calculate_ema(df, macd_ema_period)
        macd = ta.trend.MACD(df['ema_9'], window_slow=26, window_fast=12, window_sign=9)
        df['macd'] = macd.macd()
        df['signal'] = macd.macd_signal()
        df['histogram'] = macd.macd_diff()
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)
        return df
    except Exception as e:
        print(f"Error fetching OHLCV for {base_symbol}: {e}")
        return None

# Function to calculate quantity
def calculate_quantity(base_symbol, latest_close):
    min_amount = symbols_info.get(base_symbol, {'min_amount': 0.0001})['min_amount']
    quantity = min_amount * 1.01
    return quantity

# Async function to check current position
async def check_position(base_symbol):
    try:
        positions = await exchange.fetch_positions([base_symbol])
        for pos in positions:
            if pos['symbol'] == base_symbol and float(pos['contracts']) > 0:
                return pos['side'].lower(), float(pos['contracts'])
        return None, 0
    except Exception as e:
        print(f"Error checking position for {base_symbol}: {e}")
        return None, 0

# Async function to place a market buy order with TP/SL
async def place_market_buy_order(base_symbol, quantity, order_num, trade_side='open', retries=2, delay=1):
    attempt = 0
    while attempt < retries:
        try:
            if not await set_trading_parameters(base_symbol, trade_side, 'buy'):
                raise Exception("Failed to set trading parameters")
            latest_price = float((await exchange.fetch_ticker(base_symbol))['close'])
            order_id = place_order(base_symbol, 'buy', trade_side, quantity)
            if order_id and trade_side == 'open':
                tp_price = latest_price * (1 + trading_params['tp_percentage'] / 100)
                sl_price = latest_price * (1 - trading_params['sl_percentage'] / 100)
                place_tpsl_order(base_symbol, 'long', quantity, latest_price, 'profit_plan', tp_price)
                place_tpsl_order(base_symbol, 'long', quantity, latest_price, 'loss_plan', sl_price)
                print(f"Order #{order_num} - Market Buy Order with TP/SL placed for {base_symbol}: {order_id}")
            elif order_id:
                print(f"Order #{order_num} - Market Buy Order placed for {base_symbol}: {order_id}")
            return order_id
        except Exception as e:
            attempt += 1
            print(f"Order #{order_num} - Error placing Market Buy Order for {base_symbol} (Attempt {attempt}/{retries}): {e}")
            if attempt < retries:
                await asyncio.sleep(delay)
    return None

# Async function to place a market sell order with TP/SL
async def place_market_sell_order(base_symbol, quantity, order_num, trade_side='open', retries=2, delay=1):
    attempt = 0
    while attempt < retries:
        try:
            if not await set_trading_parameters(base_symbol, trade_side, 'sell'):
                raise Exception("Failed to set trading parameters")
            latest_price = float((await exchange.fetch_ticker(base_symbol))['close'])
            order_id = place_order(base_symbol, 'sell', trade_side, quantity)
            if order_id and trade_side == 'open':
                tp_price = latest_price * (1 - trading_params['tp_percentage'] / 100)
                sl_price = latest_price * (1 + trading_params['sl_percentage'] / 100)
                place_tpsl_order(base_symbol, 'short', quantity, latest_price, 'profit_plan', tp_price)
                place_tpsl_order(base_symbol, 'short', quantity, latest_price, 'loss_plan', sl_price)
                print(f"Order #{order_num} - Market Sell Order with TP/SL placed for {base_symbol}: {order_id}")
            elif order_id:
                print(f"Order #{order_num} - Market Sell Order placed for {base_symbol}: {order_id}")
            return order_id
        except Exception as e:
            attempt += 1
            print(f"Order #{order_num} - Error placing Market Sell Order for {base_symbol} (Attempt {attempt}/{retries}): {e}")
            if attempt < retries:
                await asyncio.sleep(delay)
    return None

# Async function to cancel an open order
async def cancel_open_order(base_symbol, order_id):
    try:
        if order_id:
            await exchange.cancel_order(order_id, base_symbol)
            print(f"Cancelled open order for {base_symbol}: {order_id}")
    except Exception as e:
        print(f"Error cancelling order for {base_symbol}: {e}")

# Main async trading function with MACD strategy
async def ema_strategy():
    global symbols, symbols_info, last_order_types, open_orders, last_signals
    
    while True:
        try:
            symbols_info = get_usdt_pairs()
            symbols = list(symbols_info.keys())
            
            last_order_types = {symbol: last_order_types.get(symbol) for symbol in symbols}
            open_orders = {symbol: open_orders.get(symbol) for symbol in symbols}
            last_signals = {symbol: last_signals.get(symbol) for symbol in symbols}
            
            trades_placed = 0

            for i, base_symbol in enumerate(symbols, 1):
                print(f"\nProcessing pair #{i}/{len(symbols)}: {base_symbol}")
                
                historical_data = await fetch_ohlcv(base_symbol, time_interval, 100)
                if historical_data is None or len(historical_data) < 26:
                    print(f"Not enough data for {base_symbol}. Skipping...")
                    continue

                latest_candle = await exchange.fetch_ticker(base_symbol)
                latest_close = float(latest_candle['close'])
                quantity = calculate_quantity(base_symbol, latest_close)

                current_histogram = historical_data['macd'].iloc[-2]
                prev_histogram = historical_data['macd'].iloc[-3]
                
                if current_histogram > prev_histogram:
                    current_signal = 'long'
                    print(f'{base_symbol} Potential Buy Signal')
                elif current_histogram < prev_histogram:
                    current_signal = 'short'
                    print(f'{base_symbol} Potential Sell Signal')
                else:
                    current_signal = None
                    print(f'{base_symbol} No clear signal')
                    continue

                if current_signal and last_signals.get(base_symbol) != current_signal:
                    position_side, position_size = await check_position(base_symbol)
                    if position_side:
                        if (current_signal == 'long' and position_side == 'short') or \
                           (current_signal == 'short' and position_side == 'long'):
                            trades_placed += 1
                            if position_side == 'short':
                                close_order_id = await place_market_buy_order(base_symbol, position_size, trades_placed, 'close')
                            else:
                                close_order_id = await place_market_sell_order(base_symbol, position_size, trades_placed, 'close')
                            if close_order_id and open_orders.get(base_symbol):
                                await cancel_open_order(base_symbol, open_orders[base_symbol])
                                open_orders[base_symbol] = None
                                last_order_types[base_symbol] = None

                    last_signals[base_symbol] = current_signal
                    
                    if current_signal == 'long':
                        trades_placed += 1
                        order_id = await place_market_buy_order(base_symbol, quantity, trades_placed, 'open')
                        if order_id:
                            open_orders[base_symbol] = order_id
                            last_order_types[base_symbol] = 'BUY'
                    elif current_signal == 'short':
                        trades_placed += 1
                        order_id = await place_market_sell_order(base_symbol, quantity, trades_placed, 'open')
                        if order_id:
                            open_orders[base_symbol] = order_id
                            last_order_types[base_symbol] = 'SELL'

            print(f"\nCycle completed. Total trades placed: {trades_placed}")
            await asyncio.sleep(900)
            
        except Exception as e:
            print(f'An error occurred in cycle: {e}')
            await asyncio.sleep(60)

# Run the trading strategy
async def main():
    if symbols:
        await ema_strategy()
    else:
        print("No symbols available to trade. Exiting...")

if __name__ == "__main__":
    asyncio.run(main())
